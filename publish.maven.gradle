apply plugin: 'maven'
apply plugin: 'signing'

def publishs = project.ext.publishs

version = publishs.version
group = publishs.group

//static def localMavenRepo() {
//	'file://' + new File(System.getProperty('user.home'), '.m2/repository').absolutePath
//}
//
@SuppressWarnings("GrMethodMayBeStatic")
def isReleaseBuild() {
	return !publishs.version.contains("SNAPSHOT")
}

def isAndroidApplication = project.plugins.hasPlugin('com.android.application')
def isAndroidLibrary = project.plugins.hasPlugin('com.android.library')
def isAndroidProject = isAndroidApplication || isAndroidLibrary

//
//def getReleaseRepositoryUrl() {
//	return hasProperty('LOCAL') ? localMavenRepo()
//		: hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
//		: 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
//}
//
//def getSnapshotRepositoryUrl() {
//	return hasProperty('LOCAL') ? localMavenRepo()
//		: hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
//		: 'https://oss.sonatype.org/content/repositories/snapshots/'
//}
//
//def getRepositoryUsername() {
//	return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : '')
//}
//
//def getRepositoryPassword() {
//	return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : '')
//}

afterEvaluate { project ->
	uploadArchives {
		repositories {
			mavenDeployer {
//				// allow uploading through FTP protocol with the following command:
//				// gradle uploadArchives -PSNAPSHOT_REPOSITORY_URL=ftp://host/repo/path -PUSERNAME=uname -PPASSWORD=passwd
//				configuration = configurations.create('deployerJars')
//				configuration.dependencies.add dependencies.create('org.apache.maven.wagon:wagon-ftp:2.2')
//
//				beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
//
//				repository(url: getReleaseRepositoryUrl()) {
//					authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
//				}
//				snapshotRepository(url: getSnapshotRepositoryUrl()) {
//					authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
//				}

				pom.groupId = publishs.group
				pom.artifactId = publishs.artifact
				pom.version = publishs.version

				pom.whenConfigured { pom ->
					pom.packaging = isAndroidLibrary ? 'aar' : isAndroidApplication ? 'apk' : 'jar'
//						pom.dependencies = pom.dependencies.findAll { dep ->
//							dep.artifactId.notIn(publishs.removeDependecies)
//						}
					//pom.dependencies.each { dep -> throw new Exception(dep.artifactId) }
					pom.dependencies.removeAll { dep -> dep.artifactId in publishs.removeDependecies }
				}

				pom.project {
					if (isAndroidLibrary)
						packaging = 'aar'
					else (isAndroidApplication)
					packaging = 'apk'

					name = publishs.name
					description = publishs.des
					url = publishs.url

					scm {
						url publishs.scm.url
						connection publishs.scm.connection
						developerConnection publishs.scm.developer
					}

					licenses {
						publishs.licenses.each { item ->
							if (item != null) license {
								name = item.name
								url = item.url
								distribution = item.distribution
							}
						}
					}

					developers {
						publishs.developers.each { item ->
							if (item != null) developer {
								id = item.id
								name = item.name
								email = item.email
							}
						}
					}

				}

			}
		}
	}

	signing {
		required { isReleaseBuild() && gradle.taskGraph.hasTask('uploadArchives') }
		sign configurations.archives
	}

	if (isAndroidProject) {
		def outFileType = isAndroidLibrary ? 'arr' : 'apk'

		if (isAndroidLibrary)
			project.android.libraryVariants.all { variant ->
				variant.outputs.each { output ->
					output.outputFileName = output.outputFileName.replace(".$outFileType", "-${publishs.version}.$outFileType")
				}
			}
		else
			project.android.applicationVariants.all { variant ->
				variant.outputs.each { output ->
					output.outputFileName = output.outputFileName.replace(".$outFileType", "-${publishs.version}.$outFileType")
				}
			}

		def releaseVariants = project.android.libraryVariants.findAll {
			it.buildType.name.equalsIgnoreCase('release')
		}

		def getAndroidSdkDirectory = project.android.sdkDirectory

		def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${project.android.compileSdkVersion}/android.jar"

		task androidJavadocs(type: Javadoc, dependsOn: assembleRelease) {
			source = releaseVariants.collect { it.javaCompile.source }
			classpath = files(
				getAndroidJar,
				project.file("build/intermediates/classes/release")
			)
			doFirst {
				classpath += files(releaseVariants.collect { it.javaCompile.classpath.files })
			}
			options {
				links("http://docs.oracle.com/javase/7/docs/api/")
				linksOffline("http://d.android.com/reference",
					"${getAndroidSdkDirectory}/docs/reference")
			}

			exclude '**/BuildConfig.java'
			exclude '**/R.java'
		}

		def cleanJavadocTask = task("cleanJavadocTask", type: Delete) {
			delete androidJavadocs.destinationDir
		} as Task
		project.clean.dependsOn(cleanJavadocTask)

		task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
			classifier = 'javadoc'
			from androidJavadocs.destinationDir
			baseName "${publishs.jar.prefix}${project.name}${publishs.jar.postfix}"
		}

		task androidSourcesJar(type: Jar) {
			classifier = 'sources'
			from project.android.sourceSets.main.java.source
			baseName "${publishs.jar.prefix}${project.name}${publishs.jar.postfix}"
		}

		task androidLibraryJar(type: Jar, dependsOn: compileReleaseJavaWithJavac /* == variant.javaCompile */) {
			from compileReleaseJavaWithJavac.destinationDir
			exclude '**/R.class'
			exclude '**/BuildConfig.class'
			exclude '**/R$*.class'
			baseName "${publishs.jar.prefix}${project.name}${publishs.jar.postfix}"
		}

		artifacts {
			archives androidLibraryJar
			archives androidSourcesJar
			archives androidJavadocsJar
		}
	} else if (project.plugins.hasPlugin('java')) {
		task sourcesJar(type: Jar, dependsOn: classes) {
			classifier = 'sources'
			from sourceSets.main.allSource
		}

		task javadocsJar(type: Jar, dependsOn: javadoc) {
			classifier = 'javadoc'
			from javadoc.destinationDir
		}

		artifacts {
			archives sourcesJar
			archives javadocsJar
		}
	}
	logger.info("Published artifacts in ${configurations.archives}:")
	configurations.archives.artifacts.files.files.each { logger.info("\t$it") }
}
